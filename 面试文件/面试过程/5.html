题一：数组考察（选一题）

题目：找出数组中出现次数超过一半的数字JavaScript

/* --------- 找出数组中出现次数超过一半的数字 --------- */
/* 尽量不使用 JS 特有的语法糖，尽量不使用如 Array.sort 等语言特有的方法。*/

/**
 * @param {number[]} arr - 元素内容全部为自然数的数组
 * @return {number} - 返回数组中出现次数超过数组长度一半的自然数，如果没有则返回 -1 
 */
function findMoreThanHalf(arr) {
    // your code are here...
}

// 测试用例
console.log(findMoreThanHalf([0,1,2,2])) // -1
console.log(findMoreThanHalf([0,1,2,2,2])) // 2
题目：找出最接近的值

/* --------- 找出最接近的值 ----------- */
/* 尽量不使用 JS 特有的语法糖，尽量不使用如 Array.sort 等语言特有的方法。*/
const arr2 = [1, 5, 9, 15, 28, 33, 55, 78, 99];

/**
 * 返回最接近输入值的数字，如果有多个，返回最大的那个
 * @param {number} n
 * @return {number}
 */
function findNext(n, arr) {
  // your code are here...
}

console.log(findNext(44, arr2)); // should print 55
题目：数组去重

/* --------- 数组去重 ----------- */
/* 尽量不使用 JS 特有的语法糖，尽量不使用如 Array.sort 等语言特有的方法。*/
const arr1 = [1, 1, 2, 3, 3, 3, 4, 5, 5, 7, 8, 8, 8, 9];

/**
 * 返回一个新的数组，去掉了重复的数字
 * @param {number[]} arr
 * @return {number[]}
 */
function union(arr) {
  // your code are here...
}

console.log(union(arr1)); // should print [1,2,3,4,5,6,7,8,9]


题二：常规CSS考察（选一题）

题目：CSS多边框实现

CSS 多边框实现，开放性（border/box-shadow多边框/outline/outline-offset/background/ 实框虚框)

<!DOCTYPE html>
<html lang="en">
<head>
  <title>CSS 实现多边框</title>
  <style>
    .multi-border {
      margin: 100px;
      width: 100px;
      height: 100px;
      /* TODO */
    }
  </style>
</head>
<body>
  <div class="multi-border"></div>
</body>
</html>
题目：选择器考察

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Title</title>
    <style>
        
    </style>
</head>
<body>
<!--题目说明-->
<!--将children下，第3个div子元素，背景颜色置为红色-->
<!--将children下，第2个子元素，文字颜色置为蓝色-->
<!--将children下，lang属性包含bcd，文字颜色置为绿色-->
<div>
    <div class="children">
        <div>test</div>
        <p >test</p>
        <div>test</div>
        <p>test</p>
        <div lang="abc">test</div>
        <div lang="abcd">test</div>
        <div>test</div>
        <div>test</div>
    </div>
</div>
</body>
</html>


题三：日常JS方法（选一题）

题目：实现一个方法，拆解URL参数中queryString

// 入参格式参考：
const url = 'http://sample.com/?a=1&b=2&c=xx&d#hash';
// 出参格式参考：
const result = { a: '1', b: '2', c: 'xx', d: '' };

/*拆解URL参数中queryString，返回一个 key - value 形式的 object*/
function querySearch(url) {
    // your code are here...
}


题目：实现一个Throttle or Debounce



题目：构造对应数据结构，并用DFS or BFS来实现遍历



题四：（选一题）

题目：实现一个函数，可以将数组转化为树状数据结构

// 入参格式参考：
const arr = [
  { id: 1, name: 'i1' },
  { id: 2, name: 'i2', parentId: 1 },
  { id: 4, name: 'i4', parentId: 3 },
  { id: 3, name: 'i3', parentId: 2 },
  { id: 8, name: 'i8', parentId: 7 }
];

/* 可以将数组转化为树状数据结构，要求程序具有侦测错误输入的能力*/
function buildTree(arr) {
  /**
   * 此处写代码逻辑
   */
}


题目：深拷贝

// 入参格式参考：
const originObj = {
  a: {
    b: {
      c: [1, 5, 11, 23, 422]
    }
  },
  d: function() {
    console.log('hello world');
  }
};

/*实现一个函数，可以深拷贝一个对象，对象可能包含 function*/
function clone(originObj) {
  /**
   * 此处写代码逻辑
   */
}


题目：实现findFibonacci函数

// 斐波那契数列段：从第三位起，每个数字都是前两位数字之和，不一定要从 1 开始
// 入参格式参考：
const inputArr = [13, 9, 3, 8, 5, 25, 31, 11, 21];

// 出参格式参考：
const sequence = [3, 5, 8, 13, 21];

/* 实现findFibonacci函数，在一堆正整数中，找到最长的一组斐波那契数列段*/
function findFibonacci(arr) {
  /**
   * 此处写代码逻辑
   */
}


题五：（选一题）

题目：实现一个arrange函数，可以进行时间和工作调度

// [ > … ] 表示调用函数后的打印内容

// arrange('William');
// > William is notified

// arrange('William').wait(5).do('commit');
// > William is notified
// 等待 5 秒
// > Start to commit

// arrange('William').waitFirst(5).do('push');
// 等待 5 秒
// > Start to push
// > William is notified

function arrange() {
  /**
   * 此处写代码逻辑
   */
}
题目：实现下面的find方法

var data = [
    {userId: 8, title: 'title1'},
    {userId: 11, title: 'other'},
    {userId: 15, title: null},
    {userId: 19, title: 'title2'}
];
var find = function(origin) {
    //your code are here...
}
//查找data中，符合条件的数据，并进行排序
var result = find(data).where({
    "title": /\d$/
}).orderBy('userId', 'desc');
console.log(result); // [{ userId: 19, title: 'title2'}, { userId: 8, title: 'title1' }];
题目：实现一个简单的模板引擎

var tpl = template('<p>hey there {{ name }}</p>');
var div = document.createElement('div');
div.innerHTML = tpl({ name: 'Neo' });
document.body.appendChild(div);
题目：树形结构遍历算法

下面有一个数按照行数依次递增的数字三角形，寻找一条从顶部到底边的路径（即每行选取一个数），使得路径上所经过的数字之和最小。路径上的每一步都只能往左下右下走。要求求出这个最大和，并给出具体路径。

5, 
        6,  7,
      9,  10,  3,
    12, 23,  0,  20
  8,  10,  11, 16, 8,
题目：实现一个AST解析方法，解析下列输入，输出对应树形结构（区分标签、属性、内容等）

const htmlStr = `
    <div class="widget-body" data-spm-anchor-id="a1z4o.xxss.i3.14803e15bAFF41">
         <span class="ctr-val g-csscut-more" style="display: inline-block;vertical-align: top;width:200px;”><a target="_blank" href="positionDetail.htm?id=44106" title="欢迎应聘蚂蚁金服支付宝前端工程师-杭州、上海、北京、成都">欢迎应聘蚂蚁金服支付宝前端工程师-杭州、上海、北京、成都</a></span>
    </div>`
function astParser(){
    //your code are here...
}
题目：Vue 双向绑定的理解

实现一个简单的 DOM-JS数据绑定方案，要求在 JS 中改变变量数据后 DOM 视图会自动更新

<!DOCTYPE html>
<html lang="en">
<head>
  <title>DOM-JS数据绑定方案</title>
</head>
<body>
  <div id="app">
    <h1 v-text="title"></h1>
    <p>当前时间：<span v-text="time"></span></p>
  </div>
  <script>
    function ViewBind({ el = 'body', data = {}} = {}) {
      // TODO，请在此书写代码
    }

    /**
     * step: 1
     * 调用方式类似 Vue 初始化，
     * el 代表根元素，data 中的字段会自动和 DOM 中 v-text 属性对应元素内容绑定
     **/
    const app = new ViewBind({
      el: '#app',
      data: {
        title: '这是标题',
        time: +new Date()
      }
    })
    /**
     * step: 2
     * 初始化之后页面#app显示效果如下：
      <div id="app">
        <h1 v-text="title">这是标题</h1>
        <p>当前时间戳：<span v-text="time">1522070099060</span></p>
      </div>
     * 类似于 Vue，初始化之后 app 内部有一个 data 对象，
     * 通过修改 data 对象的属性来间接修改 DOM 中挂载了对应 v-text 属性的元素内容
     **/
    setInterval(() => {
      // 定时修改页面上<span v-text="time">元素中的内容
      app.data.time = +new Date()
    }, 1000)

    /**
     * step3: 请实现上述 ViewBind 方法
     * 提示：可参考 Vue 中响应式数据绑定和指令的实现原理
     **/
  </script>
</body>
</html>
参考代码：

function ViewBind({ data = {}, el = '' } = {}) {
      this.data = {}
      const compiler = ($node) => {
        if (!$node) return
        watcher($node, 'v-text')
        for (let $child of $node.children) {
          compiler($child)
        }
      }
      const watcher = ($node, directive) => {
        const key = $node.getAttribute(directive)
        key && ($node.innerText = data[key]) && Object.defineProperty(this.data, key, {
          configurable: true,
          enumerable: true,
          get: () => data[key],
          set: val => data[key] = $node.innerText = val
        })
      }
      compiler(document.querySelector(el))
    }