1、防抖
  在第一次触发事件时，不立即执行函数，而是给出一个期限值比如200ms，然后：
    * 如果在200ms内没有再次触发滚动事件，那么就执行函数
    * 如果在200ms内再次触发滚动事件，那么当前的计时取消，重新开始计时
    
    function debounce(fn, delay) {
      let timer = null
      return () => {
        if (timer) {
          clearTimeout(timer)
          timer = setTimeout(fn, delay)
        } else {
          timer = setTimeout(fn, delay)
        }
      }
    }


/*****************************简化后的分割线 ******************************/

    function debounce(fn, delay) {
      let timer = null
      return () => {
        if (timer) {
          timer = null
        }
        timer = setTimeout(fn, delay)
      }
    }

    结论： 对于短时间内连续触发的事件（上面的滚动事件），防抖的含义就是让某个时间期限（如上面的1000毫秒）内，事件处理函数只执行一次。
  
/*****************************简化后的分割线 ******************************/


2、节流
  如果短时间内大量触发同一事件，那么在函数执行一次之后，该函数在指定的时间期限内不再工作，直至过了这段时间才重新生效。
  实现 这里借助setTimeout来做一个简单的实现，加上一个状态位valid来表示当前函数是否处于工作状态

  function throttle (fn, delay) {
    let vaildFlag = true
    return function() {
      if (!vaildFlag) {
        return
      }
      vaildFlag = false
      setTimeout(() => {
        fn()
        valid = true;
      }, delay)
    }
  }

