1、堆和栈
  栈：存储基本数据类型，自动分配内存空间，遵循先进后出的原则
  堆：存储引用类型的数据，动态分配内存，是一只先进先出的数据结构

2、进程和线程
  进程比线程要大，一个程序至少有一个进程，一个进程至少有一个线程
  
  浏览器是多进程，每个进程管理着浏览器不同的部分，主要分为
    （1）用户界面 ： 包括地址栏、前进/后退按钮、书签菜单等
    （2）浏览器引擎 ： 在用户界面和呈现引擎之间传送指令
    （3）渲染引擎 ： 在线程方面又称为UI线程，这是最为核心的部分，So也被称之为浏览器内核
    （4）GPU ： 用于提高网页浏览的体验
    （5）插件 ： 一个插件对应一个进程(第三方插件进程)
3、同步和异步
  同步：同步任务发出之后，没有结果前不返回，一旦调用返回就得到返回值，调用者会等待结果
  异步：异步调用发出后，调用者不会立即得到返回结果，而是被调用者通过状态或回调函数来处理这个调用。

  同步任务 是指在主线程上执行的任务，只有前一个任务执行完毕，下一个任务才能执行。
  异步任务 是指不进入主线程，而是进入任务队列（task queue）的任务，只有主线程任务执行完毕，任务队列的任务才会进入主线程执行。

4、事件循环
  1.所有同步任务都在主线程上执行，形成一个执行栈；
  2.只要异步任务有了运行结果，就在任务队列（task queue）（队列是一个先进先出的数据结构，而栈是一个先进后出的数据结构）之中放置一个事件；
  3.一旦执行栈中的所有同步任务执行完毕，系统就会读取任务队列,又将队列中的事件放到stack中依次执行，就是执行异步任务中的回调函数。这个过程是循环不断的，这就是Event Loop(事件循环);

5、宏任务和微任务
  异步任务又分为宏任务和微任务

  常见的宏任务和微任务：
    macro-task(宏任务，优先级低，先定义的先执行): 
      ajax，setTimeout, setInterval, setImmediate, I/O，事件，postMessage，MessageChannel（用于消息通讯）
    micro-task(微任务，优先级高，并且可以插队，不是先定义先执行):
      process.nextTick, 原生 Promise(有些实现的promise将then方法放到了宏任务中),Object.observe(已废弃), MutationObserver

  宏任务和微任务的区别：微任务是会被加入本轮循环的，而宏任务都是在次轮循环中被执行。简单就是说，微任务会比宏任务提前执行
  因为微任务的优先级较高，所以会先将微任务的异步任务取出来进行执行，当微任务的任务都执行完毕之后，会将宏任务中的任务取出来执行。
  
  当某个宏任务执行完后,会查看是否有微任务队列。如果有，先执行微任务队列中的所有任务，如果没有，会读取宏任务队列中排在最前的任务，执行宏任务的过程中，遇到微任务，依次加入微任务队列。栈空后，再次读取微任务队列里的任务，依次类推。

6、nextTick 比 promise.then 快

7、跨标签页的通讯方式有哪些
  (1) BroadCast Channel
  (2) Service Worker
  (3) LocalStorage + window.onstorage监听
  (4) Shared Worker + 定时器轮询(setInterval)
  (5) IndexedDB + 定时器轮询(setInterval)
  (6) cookie + 定时器轮询(setInterval)
  (7) window.open + window.postMessage
  (8) Websocket




  
