1、常见状态码
  1**： 继续发送请求
    100： 客户端应该继续发送请求
    101： 需要切换协议。服务器通过的Upgrade响应头字段通知客户端。

      HTML5引入的WebSocket便是这样工作的。首先客户端请求websocket所在的URL，服务器返回101，然后便建立了全双工的TCP连接。 
      注意Upgrade和Connection头字段属于Hop-by-hop字段，设置Websocket代理时需要继续设置这两个字段，而不是简单地转发请求
  2**： 请求成功
    200： 请求成功，请求所希望的响应头或数据体将随此响应返回
    201： 请求已经被实现，一个新的资源按照要求的需要被创建
    202： 服务器已接受请求，但尚未处理
    204： 服务器成功处理了请求，但是不需要任何返回内容
    205： 服务器成功处理了请求，但不需要返回任何实体内容，205响应禁止包含任何消息体。 与204不同的是，返回此状态码的响应要求请求者重置文档视图。比如用户刚刚提交一个表单，返回205后页面重置，用户可以立即填写下一个表单。
  3**： 资源找到但是需要其他操作（这些状态码用来重定向， 重定向目标在本次响应的Location头字段中指明。）
    301： 永久重定向
    302： 临时重定向  除非指定了Cache-Control或Expires，否则该响应不可缓存。
    303： 对应当前请求的响应可以在另一个URI上被找到，而且客户端应当采用GET的方式访问那个资源。 这个方法的存在主要是为了允许由脚本激活的POST请求输出重定向到一个新的资源。 303响应禁止被缓存。
    304： 304响应也是一种缓存机制。Web服务器对静态资源文件通常会采取缓存
    305： 被请求的资源必须通过指定的代理才能被访问

  4**： 客户端错误
    400：由于包含语法错误，当前请求无法被服务器理解。请求失败
    401： 当前请求需要用户验证，响应中会包含一个WWW-Authenticate字段来询问用户的授权信息。 而客户端的下次请求需要提供包含Authorization头的请求。
    403： 服务器已经理解请求，但是拒绝执行它。 比如从请求的Cookie得到的Session中可以得知当前用户无权进行该操作。
    404： 请求所希望得到的资源未被在服务器上发现。
    405： 请求行中指定的请求方法不能被用于请求相应的资源。（在Web开发中通常是因为客户端和服务器的方法不一致，比如客户端通过PUT来修改一个资源，而服务器把它实现为POST方法。 开发中统一规范就好了。）
    413： 服务器拒绝处理当前请求，因为该请求提交的实体数据大小超过了服务器愿意或者能够处理的范围。
    414： 当URI太长时，服务器可以返回414

  5**： 服务端错误
    500：服务器错误
    503： 服务器没有准备好处理请求。 常见原因是服务器因维护或重载而停机
    502： 作为网关或者代理工作的服务器尝试执行请求时，从上游服务器接收到无效的响应。
    504： 作为网关或者代理工作的服务器尝试执行请求时，未能及时从上游服务器收到响应。
    （注意与502的区别：502是接收到了无效响应比如Connection Refused； 504是响应超时，通常是被墙了。）
    505：服务器不支持请求中所使用的HTTP协议版本。

2、304和302的区别

3、http缓存策略


4、connection为keep-alive表示什么
  keep-alive 技术创建的目的，就是能在多次 HTTP 之间重用同一个 TCP 连接，从而减少创建/关闭多个 TCP 连接的开销（包括响应时间、CPU 资源、减少拥堵等）
  Connection: keep-alive
  keep-alive 是客户端和服务端的一个约定，如果开启 keep-alive，则服务端在返回 response 后不关闭 TCP 连接；同样的，在接收完响应报文后，客户端也不关闭连接，发送下一个 HTTP 请求时会重用该连接。
  在 HTTP/1.1 协议中，默认开启 keep-alive，除非显式地关闭它：
    Connection: close


5、介绍一下DNS
  使用 dns 模块创建 DNS 请求。

  A：dns.resolve，A 记录存储 IP 地址
  TXT：dns.resulveTxt，文本值可以用于在 DNS 上构建其他服务
  SRV：dns.resolveSrv，服务记录定义服务的定位数据，通常包含主机名和端口号
  NS：dns.resolveNs，指定域名服务器
  CNAME：dns.resolveCname，相关的域名记录，设置为域名而不是 IP 地址

  DNS域名解析的过程：
    1、查找浏览器缓存（浏览器缓存的时间和大小都有限制）
    2、查找系统缓存 （操作系统也会有一个域名解析的过程，在Windows中可以通过C:\Windows\System32\drivers\etc\hosts文件来设置）
    3、查找路由器缓存 
    4、查找ISP DNS 缓存 （网络配置中都会有"DNS服务器地址"这一项，操作系统会把这个域名发送给这里设置的DNS，也就是本地区的域名服务器，通常是提供给你接入互联网的应用提供商。这个专门的域名解析服务器性能都会很好，它们一般都会缓存域名解析结果，当然缓存时间是受域名的失效时间控制的，一般缓存空间不是影响域名失效的主要因素。大约80%的域名解析都到这里就已经完成了，所以ISP DNS主要承担了域名的解析工作。）
    5、递归搜索。 
  性能优化：
    1、减少DNS查找，避免重定向 
      浏览器DNS缓存 、计算机DNS缓存、 服务器DNS缓存、使用Keep-Alive特性 来减少DNS查找。考虑影响DNS缓存的因素：
        服务器可以设置TTL值表示DNS记录的存活时间
    2、DNS域解析
      * 可以通过用meta信息来告知浏览器, 我这页面要做DNS预解析 
      <script>
        <meta http-equiv="x-dns-prefetch-control" content="on" />
      </script>
      * 可以使用link标签来强制对DNS做预解析: dns-prefetch 需慎用，多页面重复DNS预解析会增加重复DNS查询次数。
      <script>
        <link rel="dns-prefetch" href="http://ke.qq.com/" />
      </script>

6、三次握手
      第一次握手：建立链接，客户端发送连接请求报文段，将SYN置为1,seq=x 然后客户端进入SYN_SEND状态，等待服务器确认
      第二次握手: 服务器收到SYN报文段，需要对这个报文段进行确认， 设置ACK = 1, ack = x+1同时自己还要发送SYN信息SYN = 1，seq = y,服务器端将上述所有信息放到一个报文段（即SYN+ACK报文段）中，一并发送给客户端，服务器进入SYN_RECV状态
      第三次握手： 客户端收到服务器的SYN+ACK报文段 将ack = y+1， 向服务器发送ACK报文段，这个报文段发送完毕以后，客户端和服务器端都进入ESTABLISHED（established）状态，完成TCP三次握手。

      为什么：
        “已失效的连接请求报文段”的产生在这样一种情况下：
          client发出的第一个连接请求报文段并没有丢失，而是在某个网络结点长时间的滞留了，以致延误到连接释放以后的某个时间才到达server。
          本来这是一个早已失效的报文段。但server收到此失效的连接请求报文段后，就误认为是client再次发出的一个新的连接请求。
          于是就向client发出确认报文段，同意建立连接。
          假设不采用“三次握手”，那么只要server发出确认，新的连接就建立了。
          由于现在client并没有发出建立连接的请求，因此不会理睬server的确认，也不会向server发送数据。
          但server却以为新的运输连接已经建立，并一直等待client发来数据。
          这样，server的很多资源就白白浪费掉了。
          采用“三次握手”的办法可以防止上述现象发生。
          例如刚才那种情况，client不会向server的确认发出确认。
          server由于收不到确认，就知道client并没有要求建立连接。 ”

7、四次分手
      第一次： 客户端设置seq = x和ack = y想服务端发送一个FIN = 1的报文段，客户端进入FIN_WAIT状态 （客户端无信息发送）
      第二次： 服务端收到FIN=1的报文段， 回复一个ACK报文段，ack = x+1.客户端进入FIN_WAIT_2状态，表示服务器同意断开链接，此时还可以发送最后的数据过去
      第三次： 服务端向客户的发送FIN=1的报文段。请求关闭链接。 服务器进入LAST_ACK状态
      第四册： 客户端收到服务器的FIN报文段，发送ACK报文，客户端进入（TIME_WAIT。等待2MSL后依然没有收到回复，则证明Server端已正常关闭，那好，客户端也可以关闭连接了。） 服务器收到ACK报文后，关闭链接


      为什么：
        TCP协议是一种面向连接的、可靠的、基于字节流的运输层通信协议。TCP是全双工模式，
        这就意味着，当主机1发出FIN报文段时，只是表示主机1已经没有数据要发送了，主机1告诉主机2，它的数据已经全部发送完毕了；但是，这个时候主机1还是可以接受来自主机2的数据；
        当主机2返回ACK报文段时，表示它已经知道主机1没有数据发送了，但是主机2还是可以发送数据到主机1的；
        当主机2也发送了FIN报文段时，这个时候就表示主机2也没有数据要发送了，就会告诉主机1，我也没有数据要发送了，之后彼此就会愉快的中断这次TCP连接。
8、https的工作原理


9、https和http的区别


10、介绍一下cdn以及它的应用场景
  CDN全称Content Delivery Network，即内容分发网络。
  其基本思路是尽可能避开互联网上有可能影响数据传输速度和稳定性的瓶颈和环节，使内容传输的更快、更稳定。

  在各个网络节点放置服务器，cdn系统能够实时的根据网络浏览和各个节点的链接，负载状况，以及到用户的距离和响应时间等信息，将用户的信息重新导向离用户最近的节点。
    1. 缓存算法[Squid]；2. 分发能力；3. 负载均衡[Nginx]（4. 基于DNS[BIND]）；5. 支持协议；

11、cdn的回源是什么

12、TCP/IP 是一类协议系统，它是用于网络通信的一套协议集合
    * TCP/IP 协议网络上的每一个网络适配器都有一个唯一的 IP 地址
    * TCP / IP 协议中数据先由上往下将数据装包，然后由下往上拆包

    * 在 TCP / IP 协议族中有两个互不相同的传输协议： TCP（传输控制协议）和 UDP（用户数据报协议）.

    IP 地址分为两个部分 主机ID和网络ID


13、tcp和UDP

  1、TCP面向连接（如打电话要先拨号建立连接）;UDP是无连接的，即发送数据之前不需要建立连接

  2、TCP提供可靠的服务。也就是说，通过TCP连接传送的数据，无差错，不丢失，不重复，且按序到达;UDP尽最大努力交付，即不保证可靠交付

  3、TCP面向字节流，实际上是TCP把数据看成一连串无结构的字节流;UDP是面向报文的

  UDP没有拥塞控制（慢启动、拥塞避免、快速重传和快速恢复），因此网络出现拥塞不会使源主机的发送速率降低（对实时应用很有用，如IP电话，实时视频会议等）
  4、每一条TCP连接只能是点到点的;UDP支持一对一，一对多，多对一和多对多的交互通信

  5、TCP首部开销20字节;UDP的首部开销小，只有8个字节
  6、TCP的逻辑通信信道是全双工的可靠信道，UDP则是不可靠信道



14、从输入url到页面展示发生了什么
    DNS解析

    TCP连接

    发送HTTP请求

    服务器处理请求并返回HTTP报文

    浏览器解析渲染页面

    连接结束

15、发送HTTP请求的过程就是构建HTTP请求报文并通过TCP协议中发送到服务器指定端口(HTTP协议80/8080, HTTPS协议443)。
    HTTP请求报文是由三部分组成: 请求行, 请求报头和请求正文。
    常见的请求报头有: Accept, Accept-Charset, Accept-Encoding, Accept-Language, Content-Type, Authorization, Cookie, User-Agent等。
    HTTP响应报文也是由三部分组成: 状态码, 响应报头和响应报文。

16、浏览器是一个边解析边渲染的过程。首先浏览器解析HTML文件构建DOM树，然后解析CSS文件构建渲染树，等到渲染树构建完成后，浏览器开始布局渲染树并将其绘制到屏幕上。
  这个过程比较复杂，涉及到两个概念: reflow(回流)和repain(重绘)。
    DOM节点中的各个元素都是以盒模型的形式存在，这些都需要浏览器去计算其位置和大小等，这个过程称为relow;
    当盒模型的位置,大小以及其他属性，如颜色,字体,等确定下来之后，浏览器便开始绘制内容，这个过程称为repain。
    页面在首次加载时必然会经历reflow和repain。reflow和repain过程是非常消耗性能的，尤其是在移动设备上，它会破坏用户体验，有时会造成页面卡顿。
    所以我们应该尽可能少的减少reflow和repain。
