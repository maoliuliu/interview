1、请求方式
  get:向特定的资源发出请求
  post:向指定资源提交数据进行处理请求（例如提交表单或者上传文件）。数据被包含在请求体中。POST请求可能会导致新的资源的建立和/或已有资源的修改
  put:向指定资源位置上传其最新内容
  options:返回服务器针对特定资源所支持的HTTP请求方法
  delete:请求服务器删除Request-URL所标识的资源
  head:
  trace：回显服务器收到的请求，主要用于测试或诊断

2、http和https
  https是在http协议基础上加入加密处理和认证机制以及完整性保护，即http+加密+认证+完整性保护=https
  https并非应用层的一种新协议，只是http通信接口部分用ssl/tls协议代替而已。通常http直接和tcp通信，当使用ssl时则演变成先和ssl通信，再由ssl和tcp通信。

  SSL:  安全套接层
  SSL协议位于TCP/IP协议与各种应用层协议之间，为数据通讯提供安全支持。SSL协议可分为两层：
  SSL记录协议（SSL Record Protocol）：它建立在可靠的传输协议（如TCP）之上，为高层协议提供数据封装、压缩、加密等基本功能的支持。
  SSL握手协议（SSL Handshake Protocol）：它建立在SSL记录协议之上，用于在实际的数据传输开始前，通讯双方进行身份认证、协商加密算法、交换加密密钥等。


  对称密钥加密，又称私钥加密，即信息的发送方和接收方用同一个密钥去加密和解密数据。它的最大优势是加/解密速度快，适合于对大数据量进行加密，但密钥管理困难。
非对称密钥加密，又称公钥加密，它需要使用一对密钥来分别完成加密和解密操作，一个公开发布，即公开密钥，另一个由用户自己秘密保存，即私用密钥。信息发送者用公开密钥去加密，而信息接收者则用私用密钥去解密。
从功能角度而言非对称加密比对称加密功能强大，但加密和解密速度却比对称密钥加密慢得多

  总结HTTP和HTTPS区别如下：
  1、https协议需要到ca申请证书，一般免费证书较少，因而需要一定费用。
  2、http是超文本传输协议，信息是明文传输，https则是具有安全性的ssl加密传输协议
  3、http和https使用的是完全不同的连接方式，用的端口也不一样，前者是80，后者是443。
  4、ttp的连接很简单，是无状态的；HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，比http协议安全。

3、HTTPS工作原理
    1、客户端发起HTTPS请求
    用户在浏览器里输入一个https网址，然后连接到server的443端口。
    2、服务端的配置
    采用HTTPS协议的服务器必须要有一套数字证书，可以自己制作，也可以向组织申请，区别就是自己颁发的证书需要客户端验证通过，才可以继续访问，而使用受信任的公司申请的证书则不会弹出提示页面。
    3、传送证书
    这个证书其实就是公钥，只是包含了很多信息，如证书的颁发机构，过期时间等等。
    4、客户端解析证书
    这部分工作是由客户端的TLS来完成的，首先会验证公钥是否有效，比如颁发机构，过期时间等等，如果发现异常，则会弹出一个警告框，提示证书存在问题。
    （1）首先浏览器读取证书中的证书所有者、有效期等信息进行一一校验
    （2）浏览器开始查找操作系统中已内置的受信任的证书发布机构CA，与服务器发来的证书中的颁发者CA比对，用于校验证书是否为合法机构颁发
    （3）如果找不到，浏览器就会报错，说明服务器发来的证书是不可信任的。
    （4）如果找到，那么浏览器就会从操作系统中取出颁发者CA 的公钥(多数浏览器开发商发布
    版本时，会事先在内部植入常用认证机关的公开密钥)，然后对服务器发来的证书里面的签名进行解密
    （5）浏览器使用相同的hash算法计算出服务器发来的证书的hash值，将这个计算的hash值与证书中签名做对比
    （6）对比结果一致，则证明服务器发来的证书合法，没有被冒充
    （7）此时浏览器就可以读取证书中的公钥，用于后续加密了
    5、传送加密信息
    这部分传送的是用证书加密后的随机值(私钥)，目的就是让服务端得到这个随机值，以后客户端和服务端的通信就可以通过这个随机值来进行加密解密了。
    6、服务端解密信息
    服务端用私钥解密后，得到了客户端传过来的随机值(私钥)，然后把内容通过该值进行对称加密
    7、传输加密后的信息
    这部分信息是服务端用私钥加密后的信息，可以在客户端被还原。
    8、客户端解密信息
    客户端用之前生成的私钥解密服务端传过来的信息，于是获取了解密后的内容，整个过程第三方即使监听到了数据，也束手无策。

4、http
  HTTP协议采用了请求/响应模型。
  客户端向服务器发送一个请求报文，请求报文包含请求的方法、URL、协议版本、请求头部和请求数据。
  服务器以一个状态行作为响应，响应的内容包括协议的版本、成功或者错误代码、服务器信息、响应头部和响应数据。

  HTTP 请求/响应的步骤：
  客户端连接到Web服务器->发送Http请求->服务器接受请求并返回HTTP响应->释放连接TCP连接->客户端浏览器解析HTML内容

5、HTTP请求消息Request
  第一部分：请求行，用来说明请求类型,要访问的资源以及所使用的HTTP版本.
  第二部分：请求头部，紧接着请求行（即第一行）之后的部分，用来说明服务器要使用的附加信息
    HOST将指出请求的目的地.User-Agent,服务器端和客户端脚本都能访问它,它是浏览器类型检测逻辑的重要基础.该信息由你的浏览器来定义,并且在每个请求中自动发送等等
  第三部分：空行，请求头部后面的空行是必须的
  第四部分：请求数据也叫主体，可以添加任意的其他数据。
6、HTTP请求消息Response
  第一部分：状态行，由HTTP协议版本号， 状态码， 状态消息 三部分组成。
  第二部分：消息报头，用来说明客户端要使用的一些附加信息
   Date:生成响应的日期和时间；Content-Type:指定了MIME类型的HTML(text/html),编码类型是UTF-8
  第三部分：空行，消息报头后面的空行是必须的
  第四部分：响应正文，服务器返回给客户端的文本信息。


vue:
  1、vue的数据双向绑定:采用 数据劫持结合发布者-订阅者模式 的方式，通过 Object.defineProperty() 来劫持各个属性的setter，getter，在数据变动时发布消息给订阅者，触发相应监听回调

  第一步：需要observe的数据对象进行递归遍历，包括子属性对象的属性，都加上 setter和getter。这样的话，给这个对象的某个值赋值，就会触发setter，那么就能监听到了数据变化
  第二步：compile解析模板指令，将模板中的变量替换成数据，然后初始化渲染页面视图，并将每个指令对应的节点绑定更新函数，添加监听数据的订阅者，一旦数据有变动，收到通知，更新视图
  第三步：Watcher订阅者是Observer和Compile之间通信的桥梁，主要做的事情是:
    1、在自身实例化时往属性订阅器(dep)里面添加自己
    2、自身必须有一个update()方法
    3、待属性变动dep.notice()通知时，能调用自身的update()方法，并触发Compile中绑定的回调，则功成身退。
  第四步：MVVM作为数据绑定的入口，整合Observer、Compile和Watcher三者，通过Observer来监听自己的model数据变化，通过Compile来解析编译模板指令，最终利用Watcher搭起Observer和Compile之间的通信桥梁，达到数据变化 -> 视图更新；视图交互变化(input) -> 数据model变更的双向绑定效果。

  2、vue请求数据放在created好还是mounted里好
    建议放在created里
  
    created:在模板渲染成html前调用，即通常初始化某些属性值，然后再渲染成视图。
    
    mounted:在模板渲染成html后调用，通常是初始化页面完成后，再对html的dom节点进行一些需要的操作。
    
    如果在mounted钩子函数中请求数据可能导致页面闪屏问题
    
    其实就是加载时机问题，放在created里会比mounted触发早一点，如果在页面挂载完之前请求完成的话就不会看到闪屏了

  3、完整的vue-router导航解析流程
  导航被触发-->在失活的组件里调用离开守卫-->
    调用全局beforeEach守卫-->
    在重用的组件里调用 beforeRouteUpdate 守卫（2.2+）-->
    在路由配置里调用beforeEnter-->
    解析异步路由组件-->
    在被激活的组件里调用beforeRouteEnter-->
    调用全局的beforeResole守卫（2.5+）-->
    导航被确认-->
    调用全局afterEach --> 
    触发DOM更新 --> 
    用创建好的实例调用beforeRouteEnter守卫中传给next的回调函数

  4、<keep-alive></keep-alive>的作用是什么?
    <keep-alive></keep-alive> 包裹动态组件时，会缓存不活动的组件实例,主要用于保留组件状态或避免重新渲染。
    大白话: 比如有一个列表和一个详情，那么用户就会经常执行打开详情=>返回列表=>打开详情…这样的话列表和详情都是一个频率很高的页面，
    那么就可以对列表组件使用<keep-alive></keep-alive>进行缓存，这样用户每次返回列表的时候，都能从缓存中快速渲染，而不是重新渲染

  5、vuex就是专门解决页面与页面之间需要的共享变量的创建、维护、变更问题的。
    页面与页面之间总会产生各种需要的共享变量，如果通过$router.param或者$router.meta来传递是远远不够的

    1、state -- vuex store 实例的根状态对象，用于定义共享的状态变量

    2、action -- 动作，向store发出调用通知，执行本地或者远端的某一个操作（可以理解为store的methods）

    3、Mutations -- 修改器，它只用于修改state中定义的状态变量

    4、geeter -- 读取器，外部程序通过它获取变量的具体值，或者在取值前做一些计算（可以认为是store的计算属性）

  6、与AngularJs的区别
    相同点：都支持指令，内置指令和自定义指令；都支持过滤器：内置过滤器和自定义过滤器；都支持双向数据绑定，都不支持低端浏览器；
    
    不同点：AngularJs的学习成本高，比如Dependency、Injecttion特性，
    而vue.js本身提供的API都比较简单、直观；
    在性能上，AngularJs依赖对数据做脏检查，所以watcher越多越慢；Vue.js使用基于依赖追踪的观察并且使用异步队列更新，所以的数据都是独立触发的。
    
  7、与React的区别
    相同点：
    
    React采用独特的JSX语法，Vue.js 在组件开发中也推崇编写.vue特殊文件格式，对文件内容都有一些约定，两者都需要编译后使用;
    中心实现相同：一切都是组件，组件实例之间可以嵌套；
    都提供合理的钩子函数，可以让开发者定制化底去处理需求，
    都不内置列数Ajax，Route等功能到核心包，而是以插件的方式加载;
    在组件开发中都支持mixins的特性了；
    
    不同点：
    
    React采用Virtual DOM会对渲染出来的结果做脏检查；
    Vue.js在模板中提供了指令，过滤器等，可以非常方便，快捷的操作Virtual DOM。


拿到服务端资源后浏览器渲染的流程：
  1. 解析 HTML 文件，构建 DOM 树，同时浏览器主进程负责下载 CSS 文件
  2. CSS 文件下载完成，解析 CSS 文件成树形的数据结构，然后结合 DOM 树合并成 RenderObject 树
  3. 布局 RenderObject 树 （Layout/reflow），负责 RenderObject 树中的元素的尺寸，位置等计算
  4. 绘制 RenderObject 树 （paint），绘制页面的像素信息
  5. 浏览器主进程将默认的图层和复合图层交给 GPU 进程，GPU 进程再将各个图层合成（composite），最后显示出页面

  * async: 当我们在 script 标记添加 async 属性以后，浏览器遇到这个 script 标记时会继续解析 DOM，同时脚本也不会被 CSSOM 阻止，即不会阻止 CRP。
  * defer: 与 async 的区别在于，脚本需要等到文档解析后（ DOMContentLoaded 事件前）执行，而 async 允许脚本在文档解析时位于后台运行（两者下载的过程不会阻塞 DOM，但执行会）。
  * 当我们的脚本不会修改 DOM 或 CSSOM 时，推荐使用 async 


  * 分析并用 **关键资源数 关键字节数 关键路径长度** 来描述我们的 CRP 。
  * 最小化关键资源数: 消除它们（内联）、推迟它们的下载（defer）或者使它们异步解析（async）等等 。
  * 优化关键字节数（缩小、压缩）来减少下载时间 。
  * 优化加载剩余关键资源的顺序: 让关键资源（CSS）尽早下载以减少 CRP 长度 。


  重绘和重排：
    1、将动画效果应用到 position 属性为 absolute 或 fixed 的元素上。
    2、避免频繁操作样式，最好一次性重写 style 属性，或者将样式列表定义为 class 并一次性更改 class 属性
    3、也可以先为元素设置 display: none，操作结束后再把它显示出来。因为在 display 属性为 none 的元素上进行的 DOM 操作不会引发回流和重绘。
    4、对具有复杂动画的元素使用绝对定位，使它脱离文档流，否则会引起父元素及后续元素频繁回流。
    5、避免频繁读取会引发回流/重绘的属性，如果确实需要多次使用，就用一个变量缓存起来。
    6、图片懒加载
     将页面中的img标签src指向一张小图片或者src为空，然后定义data-src（这个属性可以自定义命名，我才用data-src）属性指向真实的图片。
     src指向一张默认的图片，否则当src为空时也会向服务器发送一次请求。可以指向loading的地址。注意，图片要指定宽高。
     当载入页面时，先把可视区域内的img标签的data-src属性值负给src，然后监听滚动事件，把用户即将看到的图片加载。这样便实现了懒加载。

提升性能：
  1、利用Object.freeze()提升性能
    由于 Object.freeze() 会把对象冻结，所以比较适合展示类的场景，如果你的数据属性需要改变，可以重新替换成一个新的 Object.freeze()的对象。

  2、扁平化 Store 数据结构
   当接口返回的信息是如下的深层嵌套的树形结构，假如直接把这样的结构存储在 store 中，如果想修改某个 commenter 的信息，我们需要一层层去遍历找到这个用户的信息，同时有可能这个用户的信息出现了多次，还需要把其他地方的用户信息也进行修改，每次遍历的过程会带来额外的性能开销。

  3、利用服务端渲染（SSR）和预渲染（Prerender）来优化加载性能
    在一个单页应用中，往往只有一个 html 文件，然后根据访问的 url 来匹配对应的路由脚本，动态地渲染页面内容。
    单页应用比较大的问题是首屏可见时间过长。

    单页面应用显示一个页面会发送多次请求，第一次拿到 html 资源，然后通过请求再去拿数据，再将数据渲染到页面上。
    而且由于现在微服务架构的存在，还有可能发出多次数据请求才能将网页渲染出来，每次数据请求都会产生 RTT（往返时延），会导致加载页面的时间拖的很长

    

